<script>
    // 全局变量
    let isRecording = false;
    let recognition;
    let currentModelType = 'object';
    let generatedModelData = null;

    // DOM元素
    const recordBtn = document.getElementById('record-btn');
    const voiceResult = document.getElementById('voice-result');
    const keywordsContainer = document.getElementById('keywords-container');
    const generateBtn = document.getElementById('generate-btn');
    const loadingElement = document.getElementById('loading');
    const optionButtons = document.querySelectorAll('.option-btn');
    const downloadObjBtn = document.getElementById('download-obj');
    const downloadStlBtn = document.getElementById('download-stl');
    const previewContainer = document.getElementById('preview-container');
    const steps = document.querySelectorAll('.step');

    // 初始化语音识别
    function initSpeechRecognition() {
        if ('webkitSpeechRecognition' in window) {
            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'zh-CN';

            recognition.onstart = function() {
                isRecording = true;
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = '<i class="fas fa-stop"></i><span>停止录音</span>';
                voiceResult.innerHTML = '<p>正在聆听...请描述您的3D模型</p>';
            };

            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                processVoiceResult(transcript);
            };

            recognition.onerror = function(event) {
                console.error('语音识别错误:', event.error);
                voiceResult.innerHTML = '<p style="color: var(--danger-color);">语音识别失败，请重试</p>';
                resetRecordingUI();
            };

            recognition.onend = function() {
                resetRecordingUI();
            };
        } else {
            voiceResult.innerHTML = '<p style="color: var(--danger-color);">您的浏览器不支持语音识别，请使用Chrome浏览器</p>';
        }
    }

    function resetRecordingUI() {
        isRecording = false;
        recordBtn.classList.remove('recording');
        recordBtn.innerHTML = '<i class="fas fa-microphone"></i><span>开始录音</span>';
    }

    // 处理语音识别结果
    function processVoiceResult(text) {
        voiceResult.innerHTML = `<p><strong>识别结果:</strong> ${text}</p>`;
        extractKeywords(text);
        updateStep(2); // 进入第二步
    }

    // 提取关键词（简化版）
    function extractKeywords(text) {
        const shapeKeywords = ['立方体', '球体', '圆柱体', '圆锥体', '长方体', '圆环', '金字塔'];
        const colorKeywords = ['红色', '蓝色', '绿色', '黄色', '黑色', '白色', '灰色', '透明'];
        const sizeKeywords = text.match(/\d+/g) || [];
        const materialKeywords = ['光滑', '粗糙', '金属', '木质', '塑料', '玻璃', '磨砂'];
        
        const foundKeywords = [];
        
        // 检查形状关键词
        shapeKeywords.forEach(keyword => {
            if (text.includes(keyword)) foundKeywords.push(keyword);
        });
        
        // 检查颜色关键词
        colorKeywords.forEach(keyword => {
            if (text.includes(keyword)) foundKeywords.push(keyword);
        });
        
        // 检查尺寸
        if (sizeKeywords.length > 0) {
            foundKeywords.push(`${sizeKeywords[0]}cm`);
        }
        
        // 检查材质
        materialKeywords.forEach(keyword => {
            if (text.includes(keyword)) foundKeywords.push(keyword);
        });
        
        // 显示关键词
        displayKeywords(foundKeywords);
    }

    function displayKeywords(keywords) {
        keywordsContainer.innerHTML = '';
        if (keywords.length === 0) {
            keywordsContainer.innerHTML = '<p>未识别到关键词，请尝试更具体的描述</p>';
            return;
        }
        
        keywords.forEach(keyword => {
            const keywordElement = document.createElement('div');
            keywordElement.className = 'keyword';
            keywordElement.textContent = keyword;
            keywordsContainer.appendChild(keywordElement);
        });
    }

    // 更新步骤指示器
    function updateStep(stepNumber) {
        steps.forEach((step, index) => {
            if (index + 1 < stepNumber) {
                step.classList.add('completed');
                step.classList.remove('active');
            } else if (index + 1 === stepNumber) {
                step.classList.add('active');
                step.classList.remove('completed');
            } else {
                step.classList.remove('active', 'completed');
            }
        });
    }

    // 选择模型类型
    optionButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            optionButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentModelType = btn.getAttribute('data-type');
        });
    });

    // 生成3D模型
    generateBtn.addEventListener('click', async () => {
        const keywords = Array.from(keywordsContainer.querySelectorAll('.keyword'))
                            .map(el => el.textContent);
        
        if (keywords.length === 0) {
            voiceResult.innerHTML += '<p style="color: var(--danger-color);">请先通过语音描述您的模型</p>';
            return;
        }
        
        // 显示加载状态
        loadingElement.classList.add('active');
        generateBtn.disabled = true;
        updateStep(3); // 进入第三步
        
        try {
            // 根据关键词生成对应的3D模型数据
            generatedModelData = generateModelData(keywords, currentModelType);
            
            // 更新预览显示
            previewContainer.innerHTML = `
                <i class="fas fa-check-circle" style="color: var(--success-color); font-size: 3rem;"></i>
                <p style="margin-top: 15px;">3D模型生成成功！</p>
                <p><small>模型类型: ${getModelTypeName(currentModelType)}</small></p>
                <p><small>您现在可以下载模型文件</small></p>
            `;
            
            voiceResult.innerHTML += '<p style="color: var(--success-color);">3D模型生成成功！</p>';
            updateStep(4); // 进入第四步
            
        } catch (error) {
            voiceResult.innerHTML += '<p style="color: var(--danger-color);">生成失败，请重试</p>';
            updateStep(2); // 回到第二步
        } finally {
            loadingElement.classList.remove('active');
            generateBtn.disabled = false;
        }
    });

    // 根据关键词生成模型数据
    function generateModelData(keywords, type) {
        // 这里根据关键词确定模型的基本参数
        const shape = keywords.find(k => 
            ['立方体', '球体', '圆柱体', '圆锥体', '长方体', '圆环', '金字塔'].includes(k)
        ) || '立方体';
        
        const color = keywords.find(k => 
            ['红色', '蓝色', '绿色', '黄色', '黑色', '白色', '灰色', '透明'].includes(k)
        ) || '灰色';
        
        const sizeMatch = keywords.find(k => k.includes('cm'));
        const size = sizeMatch ? parseInt(sizeMatch) : 10;
        
        return {
            shape: shape,
            color: color,
            size: size,
            type: type,
            vertices: generateVertices(shape, size),
            faces: generateFaces(shape)
        };
    }

    // 生成顶点数据
    function generateVertices(shape, size) {
        const scale = size / 10;
        switch(shape) {
            case '立方体':
                return [
                    [-scale, -scale, -scale], [scale, -scale, -scale],
                    [scale, scale, -scale], [-scale, scale, -scale],
                    [-scale, -scale, scale], [scale, -scale, scale],
                    [scale, scale, scale], [-scale, scale, scale]
                ];
            case '球体':
                // 简化的球体顶点
                const vertices = [];
                const segments = 8;
                for (let i = 0; i <= segments; i++) {
                    const theta = i * Math.PI / segments;
                    for (let j = 0; j <= segments; j++) {
                        const phi = j * 2 * Math.PI / segments;
                        const x = scale * Math.sin(theta) * Math.cos(phi);
                        const y = scale * Math.sin(theta) * Math.sin(phi);
                        const z = scale * Math.cos(theta);
                        vertices.push([x, y, z]);
                    }
                }
                return vertices;
            case '圆柱体':
                // 简化的圆柱体顶点
                const cylVertices = [];
                const cylSegments = 8;
                for (let i = 0; i <= cylSegments; i++) {
                    const theta = i * 2 * Math.PI / cylSegments;
                    const x = scale * Math.cos(theta);
                    const y = scale * Math.sin(theta);
                    cylVertices.push([x, y, -scale]); // 底部
                    cylVertices.push([x, y, scale]);  // 顶部
                }
                return cylVertices;
            default:
                return generateVertices('立方体', size);
        }
    }

    // 生成面数据
    function generateFaces(shape) {
        switch(shape) {
            case '立方体':
                return [
                    [0, 1, 2, 3], // 后面
                    [4, 5, 6, 7], // 前面
                    [0, 4, 7, 3], // 左面
                    [1, 5, 6, 2], // 右面
                    [3, 2, 6, 7], // 上面
                    [0, 1, 5, 4]  // 下面
                ];
            case '球体':
                // 简化的球体面
                const faces = [];
                const segments = 8;
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < segments; j++) {
                        const a = i * (segments + 1) + j;
                        const b = a + 1;
                        const c = a + (segments + 1);
                        const d = c + 1;
                        faces.push([a, b, d, c]);
                    }
                }
                return faces;
            default:
                return generateFaces('立方体');
        }
    }

    // 获取模型类型名称
    function getModelTypeName(type) {
        const names = {
            'object': '物体/道具',
            'character': '角色/生物',
            'environment': '环境/场景',
            'architecture': '建筑/结构'
        };
        return names[type] || '物体';
    }

    // 生成OBJ文件内容
    function generateOBJContent(modelData) {
        let objContent = `# AI速模生成的3D模型\n`;
        objContent += `# 形状: ${modelData.shape}\n`;
        objContent += `# 大小: ${modelData.size}cm\n\n`;
        
        // 顶点
        modelData.vertices.forEach(vertex => {
            objContent += `v ${vertex[0].toFixed(6)} ${vertex[1].toFixed(6)} ${vertex[2].toFixed(6)}\n`;
        });
        
        objContent += `\n`;
        
        // 面
        modelData.faces.forEach(face => {
            if (face.length === 3) {
                objContent += `f ${face[0] + 1} ${face[1] + 1} ${face[2] + 1}\n`;
            } else {
                objContent += `f ${face[0] + 1} ${face[1] + 1} ${face[2] + 1} ${face[3] + 1}\n`;
            }
        });
        
        return objContent;
    }

    // 生成STL文件内容（ASCII格式）
    function generateSTLContent(modelData) {
        let stlContent = `solid AI_Generated_Model\n`;
        
        modelData.faces.forEach(face => {
            // 计算法向量（简化）
            const v1 = modelData.vertices[face[0]];
            const v2 = modelData.vertices[face[1]];
            const v3 = modelData.vertices[face[2]];
            
            // 计算法向量（叉积）
            const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
            const w = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
            const normal = [
                u[1] * w[2] - u[2] * w[1],
                u[2] * w[0] - u[0] * w[2],
                u[0] * w[1] - u[1] * w[0]
            ];
            
            // 归一化
            const length = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
            if (length > 0) {
                normal[0] /= length;
                normal[1] /= length;
                normal[2] /= length;
            }
            
            stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
            stlContent += `    outer loop\n`;
            
            // 添加顶点
            face.forEach(vertexIndex => {
                const vertex = modelData.vertices[vertexIndex];
                stlContent += `      vertex ${vertex[0].toFixed(6)} ${vertex[1].toFixed(6)} ${vertex[2].toFixed(6)}\n`;
            });
            
            stlContent += `    endloop\n`;
            stlContent += `  endfacet\n`;
        });
        
        stlContent += `endsolid AI_Generated_Model\n`;
        return stlContent;
    }

    // 下载文件函数
    function downloadFile(content, filename, contentType) {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // 下载OBJ文件
    downloadObjBtn.addEventListener('click', () => {
        if (!generatedModelData) {
            alert('请先生成3D模型');
            return;
        }
        
        const objContent = generateOBJContent(generatedModelData);
        const filename = `ai_model_${Date.now()}.obj`;
        downloadFile(objContent, filename, 'text/plain');
        
        // 显示下载成功消息
        previewContainer.innerHTML += `<p style="color: var(--success-color); margin-top: 10px;">OBJ文件下载成功！</p>`;
    });

    // 下载STL文件
    downloadStlBtn.addEventListener('click', () => {
        if (!generatedModelData) {
            alert('请先生成3D模型');
            return;
        }
        
        const stlContent = generateSTLContent(generatedModelData);
        const filename = `ai_model_${Date.now()}.stl`;
        downloadFile(stlContent, filename, 'text/plain');
        
        // 显示下载成功消息
        previewContainer.innerHTML += `<p style="color: var(--success-color); margin-top: 10px;">STL文件下载成功！</p>`;
    });

    // 初始化
    recordBtn.addEventListener('click', () => {
        if (!isRecording) {
            initSpeechRecognition();
            recognition.start();
            updateStep(1); // 进入第一步
        } else {
            recognition.stop();
        }
    });

    // 页面加载完成后的初始化
    window.addEventListener('load', () => {
        updateStep(1); // 初始状态为第一步
    });
</script>
